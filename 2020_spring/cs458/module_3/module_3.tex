\documentclass{article}

\usepackage{times}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{fullpage}
\usepackage{color}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{hyperref}
\graphicspath{{./}}

\lstset{language=c, keywordstyle={\bfseries \color{red}}, basicstyle=\footnotesize\ttfamily}
\setlength{\paperheight}{11in}
\author{Clement Tsang}

\begin{document}

\begin{center}
    \Large{CS 458 --- Module 3}
\end{center}

\section{Outline}
\begin{itemize}
    \item Allows different entities to access different resources in a shared manner.
    \item The OS needs to control this sharing and provide an interface for allowing this access.
    \item Identification and authentication are required for access control.
    \item Focus on memory protection for now.
\end{itemize}

\section{Protection in General Purpose Operating Systems}
\subsection{History}
\begin{itemize}
    \item Worth looking at how OSes have evolved until now.
    \item They now allow multiple users to use the same hardware, and added sequential abilities to run multiple \emph{executives}.  
    \item The OS should make resources available to users if required and permitted to by some policy.
    \item OSes also protect users from each other; attacks, mistakes, malware, and resource overconsumption are things to protect against, even if it is a single-user OS.
\end{itemize}
\subsection{Protection Basics}
\begin{itemize}
    \item Some protected objects:
        \begin{itemize}
            \item Memory
            \item Data
            \item CPU
            \item Programs
            \item I/O devices
            \item Networks
            \item The OS itself
        \end{itemize}
\end{itemize}

\subsection{Memory Protection}
\begin{itemize}
    \item We talk about memory protection first --- a program should not be able to read the memory of another program unless permitted.
    \item This is important as a \emph{lot} of things are stored in memory!
    \item One way to invoke security is separation --- keep a user's objects separate from another's!
    \item We can do this:
        \begin{itemize}
            \item Physically (easy but expensive and inefficient)
            \item Temporally (execute different users' programs at different times)
            \item Logically (users don't see other users)
            \item Cryptographically (make users unable to see other user's data unencrypted)
        \end{itemize}
    \item But sometimes, users do want to share resources.
    \item For example, library routines or files/DB records.
    \item OSes should allow for flexible sharing --- but this creates new questions:
        \begin{itemize}
            \item Which files to share?  What part?
            \item Which users?
            \item Which users can share objects further?
            \item What uses are permitted?  R/W/E perms?  Maybe only specific bits of information (ie: only aggregate info, not individual entries of a DB).
            \item How long?
        \end{itemize}
    \item Often, for memory protection, the OS can exploit hardware support (virtual memory from CS 350) for a cheap solution.
    \item Memory addresses used are virtual and the MMU will manage this and translate to physical addresses.
    \item the OS maintains the mapping tables the MMU will use and deals with raised exceptions from the MMU.
    \item What kinds of hardware support is used for memory protection?
    \item The simplest is a fence register --- exception if the memory access below addresses is in the fence register.
    \begin{itemize}
        \item This protects the OS from user programs.
        \item This only works for a single-user OS.
    \end{itemize}
    \item Another technique is base/bound register pairs.
        \begin{itemize}
            \item This throws an exception if memory access is below/above an address in the base/bound register.
            \item Each user program has different values.
            \item When a ctx switch occurs, the OS is responsible for moving the current base/bond registers to the currently executing user program.
            \item We can extend this to have 2 base-bound pairs, one for code, one for data.
            \item This approach is more flexible.
        \end{itemize}
    \item The tagged architecture takes this to the extreme; each memory word has one or more extra bits that identify access rights to the word.
        \begin{itemize}
            \item This is very flexible, but it incurs a large overhead and is not portable at all.
        \end{itemize}
    \item Segmentation is a common approach (remember CS 350?).
        \begin{itemize}
            \item Each program has multiple address spaces, or segments.
            \item We have different segments for code, data, stack, though this can be split up even further.
            \item The virtual address contains of two parts --- the segment name, and the offset within the segment.
            \item The OS will keeps mappings from the segment name to its base physical address in the segment table; one is made for each process.
            \item The OS can relocate/resize segments and share them between processes.
            \item The segment table can also keep protection attributes.
            \item However, because of the resizing/relocation capabilities, this means every access requires a bounds check.
        \end{itemize}
    \item In paging, we divide the virtual and physical address spaces into pages and frames respectively.  Frame size is equal to page size.
        \begin{itemize}
            \item The virtual address consists of the page number and offset within page.
            \item The number of bits for the offset is $\log_2($page size$)$.
            \item The OS keeps the mapping from page number to its base physical address in the page table.
            \item Similarly to segmentation, protection attributes are kept in the page table.
            \item Typically used; advantages are:
                \begin{itemize}
                    \item Each address reference is checked for protection by hardware
                    \item Prevent users from accessing unpermitted pages
                    \item Less used pages can be moved to disk
                    \item Users can share access to a page
                \end{itemize}
            \item Disadvantages:
                \begin{itemize}
                    \item Internal fragmentation still is a problem
                    \item Assigning different levels of protection of different classes of data items is not feasible
                \end{itemize}
        \end{itemize}
    \item The x86 architecture supports both segmentation and paging, though paging is more common.
    \item Memory protection bits can indicate no access, R/W access, or RO access.
    \item Processors now also typically include a no execute bit, or NX bit.  This forbids execution of instructions stored in a page, which would make the stack/heap non-executable.
    \item Note that this does not stop buffer overflow attacks; see module 2 (see return oriented programming, where we don't inject new code but change existing code to do what we want).
\end{itemize}

\subsection{Access Control}
\begin{itemize}
    \item Access control has 3 goals:
        \begin{enumerate}
            \item Check every access
            \item Enforce the least privilege
            \item Verify acceptable use
        \end{enumerate}
    \item To describe the access control matrix, we first define some sets:
        \begin{itemize}
            \item Set of protected objects: $O$
            \item Set of protected subjects: $S$
            \item Set of rights: $R$
        \end{itemize}
        The access control matrix consists of entries $a[s, o]$, where $s \in S$, $o \in O$, and $a[s, o] \subseteq R$.
    \item For example, we could make a table like:
        \begin{table}[h]
        \centering
        \begin{tabular}{|l|l|l|l|}
        \hline
              & File 1 & File 2 & File 3 \\ \hline
        Alice & orw    & rx     & o      \\ \hline
        Bob   & r      & orx    &        \\ \hline
        Carol &        &        &        \\ \hline
        \end{tabular}
        \end{table}
    \item Often, access control matrices are not actually implemented as a matrix\dots the size and time would be awful to deal with.
    \item It's too sparse!
    \item Instead, typically they use access control lists, a set of capabilities, or some combination.
    \item An access control list, or ACL, is such that each object has a list of subjects and their access rights.
    \item We can quickly determine sets of allowed users per object, or revoking access to one specific object, but determining which objects a user can access or revoking a user's access to all objects is slow.
    \item For example, digital signatures.
    \item We can make tokens transferable.
    \item An example of combining usage of ACLs and capabilities:
        \begin{itemize}
            \item In Unix, each file has an ACL, which is consulted when executing an \lstinline{open()} call.
            \item If approved, then the caller is given a capability listing type of access allowed in ACL.
            \item Upon \lstinline{read()} or \lstinline{write()} call, the OS looks at capability to determine whether type of access is allowed.
            \item This doesn't completely mediate; it does not check \emph{every} access.
        \end{itemize}
    \item Another way to do access control is role-based access control, or RBAC.
    \item Administrators assign users to roles and grant access rights to roles.
    \item This is similar to groups but groups are less flexible.  A group is a set of subjects, while a role is as set of privileges to objects.
    \item When a user takes over a new role, they need to update only their role assignment, not all their access rights.
    \item Many commercial DBs do this.
    \item Also supports more complex access control scenarios:
        \begin{itemize}
            \item Hierarchical roles --- a manager is also an employee; this reduces the number of role/access rights assignments
            \item Users can have multiple roles and assume/give up roles as required
            \item Separation of duty --- maybe a task needs two people of different roles that cannot be the same person
        \end{itemize}
\end{itemize}

\section{User Authentication}
\begin{itemize}
    \item Computers often have to identify and authenticate users before authorizing them.
    \item Difficult for computers to do for people both locally and remotely.
    \item Four classes of authentication factors:
        \begin{itemize}
            \item Something the user knows
            \item Something the user has
            \item Something the user is (biometrics)
            \item Something about the user's context (location, time, devices in proximity, etc.)
        \end{itemize}
    \item Authentication factors may be combined for multi-factor authentication (ie: 2FA).
    \item Using multiple factors from the same class may not be a good idea; for example 2 passwords isn't really useful.
    \item Also, must make sure the factor cannot be changed --- for example, a factor the user has can become a factor the user knows, like tokens that can be easily duplicated (mag strips) or SMS messages (ie: SIM-jacking).
\end{itemize}

\subsection{Passwords}
\begin{itemize}
    \item A familiar and old authentication method.
    \item Enter an ID and password, potentially multiple attempts are allowed.
    \item Many usability problems:
        \begin{itemize}
            \item Entering passwords may be inconvenient.
            \item Password composition/change rules.
            \item Forgotten passwords may not be recoverable; people tend to forget them.
            \item If a password is shared then updating passwords is difficult.
        \end{itemize}
    \item And security problems:
        \begin{itemize}
            \item If the password is leaked, then an individual can immediately access the protected resource unless something like 2FA is used.
            \item Shoulder surfing.
            \item Keylogging.
            \item Interface illusions/phishing.
            \item Password re-use.
            \item Password guessing (brute-forcing, for example).
        \end{itemize}
    \item Some guessing attacks are exhaustive searching, dictionary attacks, etc.
    \item In online attacks, we can try to stop this by rate-limiting.  This can still be defeated by social engineering mechanisms, though.  For example, bypassing via secret questions/recovery methods.
    \item Password hygiene can be helped by things like password managers (though this now keeps all eggs in one basket), or passphrases that are easier to remember but still hard to guess.
    \item Don't reveal your passwords, don't use passwords on public computers, and don't re-use passwords.
    \item Advice for developers:
        \begin{itemize}
            \item Don't use password composition rules.
            \item At least 8 characters minimum length.
            \item At least 64 characters max length.
            \item Allow any characters.
            \item Blacklist frequently used/compromised passwords.
            \item Avoid password hints or secret questions.
            \item Don't force users to change passwords.
            \item Allow passwords to be copy-pasted.
            \item Use 2FA (but avoid SMS-based).
        \end{itemize}
    \item Attacks on password files --- websites need to store passwords (or something) in a file to validate password inputs.
    \item Passwords in plaintext is a stupid idea as access to it from an intruder or\dots anyone really, could immediately screw over a lot of people.
    \item Cryptographic tools:
        \begin{itemize}
            \item Hash --- compute a fixed-length, one-way output.  Deterministic.
            \item MAC --- takes a secret key as an input value; otherwise a hash.  Deterministic.
        \end{itemize}
    \item Now, store a hash of the password in the password file.
    \item Compare the \emph{hash of the input} with the stored hash (fingerprint).
    \item But this would still allow offline guessing attacks\dots
    \item Add a user-specific \emph{salt} to the password fingerprint.
    \item So two users with the same password have different fingerprints.
    \item This makes pre-computed tables useless.
    \item Using an iterated hash function which is slow to compute is better than using a standard hash function that would be fast to compute.
    \item This would not be noticed when a user inputs a password, but much more noticeable during a brute-force attack.
    \item Then, to make it better, throw in a MAC instead of a cryptographic hash.
    \item This adds a secret key required to compute the password fingerprint.
    \item This makes guessing attacks based on the fingerprints alone useless, but would require some kind of secret key generation/storage, using software/hardware.
    \item If the key does leak, then the scheme remains as secure as a scheme based on solely a cryptographic hash.
    \item How do we do password recovery?
    \item Well, that would require storing the password in some way\dots that's a no-go.
    \item So, use password-resetting mechanisms instead!
    \item Interception attacks --- intercept the password as it is being sent to the server.
    \item OTP (one-time passwords) make this attack useless; for example fobs, auth. apps, challenge-response protocols.
    \item A challenge-response protocol is using a random challenge to the client and the completion of the client + password computes a one-time password.
    \item Also, passwords (or their hashes) are usually encrypted via TLS to protect from interception attacks.
    \item Though sometimes, they're still transmitted via PT!
    \item There are also cryptographic protocols, like SRP, that make intercepted info useless to an attacker.
    \item Unlock patterns are an alternative.
    \item May have an issue; fingerprints/smudges may reveal the combination!
    \item Another graphical password is image selection; this has some issues with randomness and shoulder-surfing.
    \item Systems should authenticate the user, but the user should also authenticate the server is real!
    \item Biometrics are hailed as a way to get rid of problems with password and token-based authentication.
    \item Problems:
        \begin{itemize}
            \item Observed fingerprint just has to be \emph{close enough}, otherwise it would be too hard to use reliably.
            \item Could potentially be tricked if not done correctly (ie: face identification).
            \item Not secret!
            \item Cannot change!
        \end{itemize}
    \item Authentication vs. identification --- former is checking whether a captured trait corresponds to a particular stored trait, while the latter is if it corresponds to \emph{any of the stored traits}.
    \item False positives can make biometrics-based identification useless (ie: Alice is accepted as Bob).
    \item Another potential example of the base rate fallacy --- if the base rate is low and there are some false positives, it will seem like a huge failure.
    \item More issues with biometrics: privacy, accuracy.
\end{itemize}

\end{document}
