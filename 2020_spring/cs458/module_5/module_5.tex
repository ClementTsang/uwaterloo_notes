\documentclass{article}

\usepackage{times}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{fullpage}
\usepackage{color}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{hyperref}
\graphicspath{{./}}

\lstset{language=c, keywordstyle={\bfseries \color{red}}, basicstyle=\footnotesize\ttfamily}
\setlength{\paperheight}{11in}
\author{Clement Tsang}

\begin{document}

\begin{center}
    \Large{CS 458 --- Module 5: Internet Application Security and Privacy}
\end{center}

\section{Cryptography}
\begin{itemize}
    \item Recall Kerchhoffs' Principle/Shannon's Maxim --- \emph{assume the enemy knows the system}.
    \item We assume that Eve:
        \begin{itemize}
            \item May know the algorithm
            \item May know part of the plaintext
            \item May have many plaintext/ciphertext pairs
            \item May have access to an encryption/decryption oracle
        \end{itemize}
\end{itemize}

\subsection{Secret-key Encryption}
\begin{itemize}
    \item AKA symmetric encryption.
    \item Requires using a key to encrypt and decrypt the message.
    \item A theoretically perfect cryptosystem is the OTP; but this is very hard to use in practice since any key reuse ruins it, and must be truly random (pseudorandomness is not enough).
    \item SKES relies on mathematical problems that are hard to do in the opposite direction.  This may not hold true with quantum computing for some currently-used options!
    \item Two main types --- stream and block ciphers.
    \item A stream cipher takes in a keystream, XORs with the PT, and gets the CT.
    \item Can be very fast, and useful if you need to send a lot of data securely, but can be tricky to use correctly.
    \item To avoid key re-use, we may use IVs/salts to help make the key different.
    \item Block ciphers operate by taking part of the plaintext and spitting out the corresponding ciphertext.
    \item What happens when the PT is larger than one block?  We have \emph{modes of operation} for this:
        \begin{itemize}
            \item ECB uses the same keystream for each block --- but this degrades into a shitty substitution cipher!
            \item Other examples are CBC, CTR, GCM, etc, that starts with an IV. 
        \end{itemize}
    \item One problem with SKES is how to share keys?
\end{itemize}

\subsection{Public-key Encryption}
\begin{itemize}
    \item Allows Alice to send a secret message to Bob without a pre-arranged shared secret!
    \item Each user has a public key and a private key.
    \item These use a lot of math to allow for Alice to encrypt via Bob's public key and Bob to decrypt via his private key. 
    \item One downside with PKES is that a key size must be \emph{much} larger to get equivalent security to, for example, an AES SKES key.
    \item Another is that with larger keys, means more time.  This is slow to practically use for some use cases!
    \item We may instead use \emph{hybrid} cryptography.  This uses PKES to encrypt smaller messages, like a key for a SKES system, then encrypt the messages via SKES!
\end{itemize}

\section{Integrity}
\begin{itemize}
    \item How do we check if a message was changed in transit?
    \item The simplest answer is a checksum.  For example, credit card numbers use checksums.
    \item However, simple checksums are easily faked by changing specific parts of the data; and so for our messages, this is not viable!
    \item So, we need a ``cryptographic'' checksum that Mallory could not easily forge.
    \item Hash functions take in an arbitrary length string and output a fixed length string, called a message digest.
    \item Hash functions should have 3 properties:
        \begin{enumerate}
            \item Preimage resistance --- given $y$, it should be one-way.
            \item Second preimage resistance --- given $x$, it is hard to find $x' \neq x$ where $h(x) = h(x')$.
            \item Collision resistance --- it is hard to find \emph{any} two distinct $x, x'$ where $h(x) = h(x')$.
        \end{enumerate}
    \item Collisions are always easier to find than preimages or second preimages due to the birthday paradox.
    \item Usually a square root of the total size possible!
    \item For SHA-1, for example, $2^{160}$ work to find a PI or SPI, but $2^{80}$ to brute force a collision.
    \item But you can't just send an unencrypted message and its hash to get integrity assurance, as then Mallory could change the message and give her own message digest!
    \item So, there has to still be a secure way of sending and/or storing the message digest.
\end{itemize}

\section{Authentication}
\begin{itemize}
    \item Message authentication codes, or MACs, are a keyed hash function.  Only those who know the secret key can generate/check the MAC.
    \item Typically when we combine confidentiality, we encrypt then MAC.
    \item Repudiation is when Bob can ensure that Alice is the one who sent the message $M$ and it has not been modified.
    \item With something like a shared system, this is impossible, as Alice could claim Bob, who also has access to the hash system, made it up.
    \item Both repudiation and non-repudiation can be desirable based on the situation.
    \item For non-repudiation, we need a true digital signature, where Bob can prove to a third party that Alice sent it, and Bob cannot have forged it.
    \item We could use a public-key system to do so.  By Alice signing via her private signature key, then Bob could verify the message with Alice's public verification key.
    \item We often use hybrid signatures, as signing large messages is slow.  Alice can send an unsigned message and a signature on the hash of their message, for example.
    \item Typically, the signature key pair is long-lived, while the encryption key pair is short lived.  This helps give perfect forward secrecy.
    \item When creating a new encryption key pair, Alice uses her signing key to sign her new encryption key and Bob uses Alice's verification key to verify this.
\end{itemize}

\subsection{Key Management}
\begin{itemize}
    \item One of the hardest problems if PKES is how do we manage keys?
    \item Bob could find Alice's verification manually, for example (SSH).
    \item Or maybe get a friend to tell them, via a web of trust (PGP).
    \item Or trust a third party to tell them (Certificate Authority, TLS/SSL).
    \item A CA generates a certificate consisting of Alice's personal info and her verification key.  This certificate is signed with the CA's signature key.
    \item So, one only needs the verification key of the root CA to verify the certificate chain.
\end{itemize}

\section{Security Controls using Cryptography}
\begin{itemize}
    \item In what situations might it make sense to use cryptography as a security control?
    \item Remember there needs to be some separation, since any secrets need to available to legitimate users but not the adversary.
    \item In some situations, this makes SKES hard.  If your web browser can decrypt the file containing passwords, then an adversary can as well!
    \item PKES would be fine if the local machine only has access to the public part of the key.
    \item But this would mean you can't decrypt or sign.
    \item We can also encrypt code.  The processor would have to decrypt instructions before executing them; malware can't spread without knowing a processor's keyg.
    \item We can encrypt data.  This provides protection if hardware containing data is stolen.  It doesn't protect against legitimate users or malware or someone who can access the device while it is operational/from memory.
\end{itemize}

\end{document}
